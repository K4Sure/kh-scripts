#!/usr/bin/env bash
# cml-truecolor.sh — Color Master Library — TrueColor Engine
# Single source of truth for TrueColor + fallback palettes / gradients
# Drop-in: ~/kh-scripts/library/colors/cml-truecolor.sh
# Version:
CML_TRUECOLOR_VERSION="v1.6.0-stable"

# --- Helpers (do NOT set -e globally because this file may be sourced) ---

# Detect TrueColor support
cml_truecolor_supported() {
  [[ "${COLORTERM:-}" == *truecolor* ]] || [[ "${TERM:-}" == *-truecolor* ]]
}

# Trim CR/LF, whitespace
_cml_trim() {
  local s="$1"; s="${s//$'\r'/}"; s="${s#"${s%%[![:space:]]*}"}"; s="${s%"${s##*[![:space:]]}"}"; printf '%s' "$s"
}

# Refresh current theme from .cml_theme (returns the theme name)
cml_refresh_theme() {
  local file="${CML_DIR:-$HOME/kh-scripts/library/colors}/.cml_theme"
  if [[ -f "$file" ]]; then
    local t; t="$(_cml_trim "$(cat "$file")")"
    t="${t^^}"   # uppercase
    printf '%s' "${t:-CLASSIC}"
  else
    printf '%s' "CLASSIC"
  fi
}

# Hex (#RRGGBB or RRGGBB) -> prints "R G B" or returns non-zero on bad input
hex_to_rgb() {
  local hex="${1##\#}"
  [[ ${#hex} -eq 6 ]] || return 1
  # base16 conversion
  printf '%d %d %d' $((16#${hex:0:2})) $((16#${hex:2:2})) $((16#${hex:4:2}))
}

# 24-bit RGB FG / BG
rgb_fg() { printf '\033[38;2;%d;%d;%dm' "$1" "$2" "$3"; }
rgb_bg() { printf '\033[48;2;%d;%d;%dm' "$1" "$2" "$3"; }
cml_reset() { printf '\033[0m'; }

# 256-color fallback (simple mapping table — extendable)
cml_fallback_color() {
  # argument = friendly name or index. If index numeric, use directly.
  local key="$1"
  case "${key^^}" in
    RED)    printf '\033[38;5;196m' ;;  # bright red
    GREEN)  printf '\033[38;5;46m'  ;;
    BLUE)   printf '\033[38;5;33m'  ;;
    YELLOW) printf '\033[38;5;226m' ;;
    ORANGE) printf '\033[38;5;208m' ;;
    PURPLE) printf '\033[38;5;201m' ;;
    CYAN)   printf '\033[38;5;51m'  ;;
    *) 
      if [[ "$key" =~ ^[0-9]+$ ]]; then
        printf '\033[38;5;%sm' "$key"
      else
        printf '\033[0m'
      fi
      ;;
  esac
}

# --- Palette loader ---
# When you add themes, add them here: (GRAD_START, GRAD_END, C1..C3)
cml_load_palette() {
  local theme="${1:-$(cml_refresh_theme)}"
  theme="${theme^^}"
  # defaults
  CML_GRAD_START="#CCCCCC"
  CML_GRAD_END="#FFFFFF"
  CML_C1="#FFFFFF"
  CML_C2="#AAAAAA"
  CML_C3="#FFD700"

  case "$theme" in
    "CLASSIC")
      CML_GRAD_START="#DCDCDC"; CML_GRAD_END="#6E6E6E"
      CML_C1="#FFFFFF"; CML_C2="#BFBFBF"; CML_C3="#FFD700"
      ;;
    "NEON:RED"|"NEON:RED")
      CML_GRAD_START="#FF2D55"; CML_GRAD_END="#FF9AAF"
      CML_C1="#FF2D55"; CML_C2="#FF9AAF"; CML_C3="#FFFFFF"
      ;;
    "NEON:ORANGE")
      CML_GRAD_START="#FF6A00"; CML_GRAD_END="#FFD580"
      CML_C1="#FF6A00"; CML_C2="#FFB14D"; CML_C3="#FFFFFF"
      ;;
    "NEON:YELLOW")
      CML_GRAD_START="#FFD700"; CML_GRAD_END="#FFFF99"
      CML_C1="#FFD700"; CML_C2="#FFF59A"; CML_C3="#000000"
      ;;
    "NEON:GREEN")
      CML_GRAD_START="#00FF6A"; CML_GRAD_END="#B9FFB9"
      CML_C1="#00FF6A"; CML_C2="#A0FFA0"; CML_C3="#000000"
      ;;
    "NEON:BLUE")
      CML_GRAD_START="#00A7FF"; CML_GRAD_END="#A6ECFF"
      CML_C1="#00A7FF"; CML_C2="#7FD7FF"; CML_C3="#FFFFFF"
      ;;
    "NEON:PURPLE")
      CML_GRAD_START="#9A4DFF"; CML_GRAD_END="#E0B3FF"
      CML_C1="#9A4DFF"; CML_C2="#CFA6FF"; CML_C3="#FFFFFF"
      ;;
    "FOREST")
      CML_GRAD_START="#0B6623"; CML_GRAD_END="#8FE39E"
      CML_C1="#0B6623"; CML_C2="#2E8B57"; CML_C3="#A8E6A3"
      ;;
    "DESERT")
      CML_GRAD_START="#C2A77B"; CML_GRAD_END="#F7E7C4"
      CML_C1="#C2A77B"; CML_C2="#E0C9A9"; CML_C3="#FFF7E0"
      ;;
    "OCEAN")
      CML_GRAD_START="#02457A"; CML_GRAD_END="#29B6F6"
      CML_C1="#02457A"; CML_C2="#00B4FF"; CML_C3="#66CCFF"
      ;;
    "SUMMER")
      CML_GRAD_START="#FFD447"; CML_GRAD_END="#B8FF67"
      CML_C1="#FFD447"; CML_C2="#D7FF91"; CML_C3="#2ECC71"
      ;;
    "WINTER")
      CML_GRAD_START="#0C7BD0"; CML_GRAD_END="#BFE7FF"
      CML_C1="#0C7BD0"; CML_C2="#4CA6E7"; CML_C3="#E6F7FF"
      ;;
    "WILD")
      CML_GRAD_START="#FF2D95"; CML_GRAD_END="#39FF83"
      CML_C1="#FF2D95"; CML_C2="#39FF83"; CML_C3="#FFFFFF"
      ;;
    # Add more themes here. Keep the format above.
    *)
      # fallback (CLASSIC)
      CML_GRAD_START="#DCDCDC"; CML_GRAD_END="#6E6E6E"
      CML_C1="#FFFFFF"; CML_C2="#BFBFBF"; CML_C3="#FFD700"
      ;;
  esac

  # expose palette variables
  export CML_GRAD_START CML_GRAD_END CML_C1 CML_C2 CML_C3
}

# --- Internal helpers for interpolation ---
__interp_channel() {
  local s=$1 e=$2 pos=$3 tot=$4
  if (( tot <= 0 )); then printf '%d' "$s"; return; fi
  # integer arithmetic interpolation
  printf '%d' $(( s + ( (e - s) * pos ) / tot ))
}

# --- API: apply gradient across a text ---
# Usage: cml_apply_theme_gradient "TEXT" [THEME]
cml_apply_theme_gradient() {
  local text="$1"; local theme="${2:-$(cml_refresh_theme)}"
  # ensure palette loaded
  cml_load_palette "$theme"
  # parse start/end to RGB
  local s_hex="${CML_GRAD_START##\#}" e_hex="${CML_GRAD_END##\#}"
  local r1 g1 b1 r2 g2 b2
  read -r r1 g1 b1 <<< "$(hex_to_rgb "$s_hex")" || return 1
  read -r r2 g2 b2 <<< "$(hex_to_rgb "$e_hex")" || return 1

  # length in characters (bash string length; multi-byte chars may count >1)
  local n=${#text}
  local tot=$(( n > 1 ? n - 1 : 1 ))
  local i=0
  # iterate each character (safe: uses read -n1)
  local ch
  while IFS= read -r -n1 ch; do
    local r=$(__interp_channel "$r1" "$r2" "$i" "$tot")
    local g=$(__interp_channel "$g1" "$g2" "$i" "$tot")
    local b=$(__interp_channel "$b1" "$b2" "$i" "$tot")
    if cml_truecolor_supported; then
      printf '%s' "$(rgb_fg "$r" "$g" "$b")${ch}$(cml_reset)"
    else
      # fallback: print whole text with cml_fallback_color near midpoint
      local mid=$(( tot / 2 ))
      if (( i == mid )); then
        printf '%s' "$(cml_fallback_color "${CML_C1}")${ch}$(cml_reset)"
      else
        printf '%s' "${ch}"
      fi
    fi
    ((i++))
  done <<< "$text"
  printf '\n'
}

# --- API: render gradient bar ---
# Usage: cml_render_gradient_bar [WIDTH] [THEME]
cml_render_gradient_bar() {
  local width="${1:-}"
  local theme="${2:-$(cml_refresh_theme)}"
  cml_load_palette "$theme"

  # determine default width ~ half screen
  if [[ -z "$width" ]]; then
    local cols
    cols="$(tput cols 2>/dev/null || echo 80)"
    width=$(( cols / 2 ))
    (( width < 10 )) && width=10
  fi

  local s_hex="${CML_GRAD_START##\#}" e_hex="${CML_GRAD_END##\#}"
  local r1 g1 b1 r2 g2 b2
  read -r r1 g1 b1 <<< "$(hex_to_rgb "$s_hex")" || return 1
  read -r r2 g2 b2 <<< "$(hex_to_rgb "$e_hex")" || return 1

  local i=0
  local tot=$(( width - 1 ))
  while (( i < width )); do
    local r=$(__interp_channel "$r1" "$r2" "$i" "$tot")
    local g=$(__interp_channel "$g1" "$g2" "$i" "$tot")
    local b=$(__interp_channel "$b1" "$b2" "$i" "$tot")
    if cml_truecolor_supported; then
      # two spaces per step for visibility
      printf '%s' "$(rgb_bg "$r" "$g" "$b")  $(cml_reset)"
    else
      # fallback to 256 background index ~ pick a mapped color
      printf '%s' "$(cml_fallback_color "${CML_C2}")" # not perfect but works
      printf '  '
      printf '%s' "$(cml_reset)"
    fi
    ((i++))
  done
  printf '\n'
}

# Simple color wrapper: cml_colorize "TEXT" "#RRGGBB" (or theme name fallback)
cml_colorize() {
  local text="$1"; local color="$2"
  if cml_truecolor_supported; then
    local rgb; rgb="$(hex_to_rgb "${color##\#}" 2>/dev/null)" || { printf '%s\n' "$text"; return; }
    read -r r g b <<< "$rgb"
    printf '%s' "$(rgb_fg "$r" "$g" "$b")${text}$(cml_reset)"
  else
    printf '%s' "$(cml_fallback_color "${color}")${text}$(cml_reset)"
  fi
  printf '\n'
}

# Title helper (for other scripts to call)
cml_title() {
  local text="$1"; local theme="${2:-$(cml_refresh_theme)}"
  cml_apply_theme_gradient "$text" "$theme"
}

# Export the API functions so other sourced scripts can call them
# (exporting functions is optional but helpful if other bash subshells use them)
export -f cml_truecolor_supported hex_to_rgb rgb_fg rgb_bg cml_load_palette \
  cml_apply_theme_gradient cml_render_gradient_bar cml_colorize cml_refresh_theme cml_reset cml_title

# Engine load banner (printed when the file is sourced; kept minimal)
# avoid printing multiple banners if sourced repeatedly: use guard
if [[ -z "${CML_TRUECOLOR_LOADED:-}" ]]; then
  CML_TRUECOLOR_LOADED=1
  export CML_TRUECOLOR_LOADED
  # Print a compact banner in theme-aware color
  local now_theme
  now_theme="$(cml_refresh_theme)"
  cml_apply_theme_gradient "✔ COLOR MASTER TRUECOLOR ENGINE LOADED (${CML_TRUECOLOR_VERSION})" "$now_theme"
fi

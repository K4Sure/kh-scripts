#!/usr/bin/env bash
# CML General Test Harness - v4.6.9
# Deterministic accent discovery + theme-name -> color fallback.
set -u

CML_DIR="${HOME}/kh-scripts/library/colors"
ENGINE_FILE="$CML_DIR/cml-truecolor.sh"
THEME_FILE="$CML_DIR/.cml_theme"
BACKUP_DIR="${HOME}/kh-scripts/backup"
CML_VERSION="v4.6.9"

# Basic safe reset
C_RESET="${C_RESET:-$'\033[0m'}"

# Make sure backup dir exists and back up this script if present
mkdir -p "$BACKUP_DIR"
if [ -f "$CML_DIR/cml-test.sh" ]; then
  cp -p "$CML_DIR/cml-test.sh" "$BACKUP_DIR/cml-test_$(date +%Y%m%d_%H%M%S).bak"
fi

# Source engine if available
if [ -f "$ENGINE_FILE" ]; then
  # shellcheck disable=SC1090
  source "$ENGINE_FILE" >/dev/null 2>&1 || true
else
  printf "%b\n" "‚ùå MISSING ENGINE: $ENGINE_FILE"
  # continue ‚Äî script has robust fallbacks
fi

# Utilities
_repeat() {
  local n=$1 ch=$2 out=""
  while [ "$n" -gt 0 ]; do out="${out}${ch}"; n=$((n-1)); done
  printf "%s" "$out"
}

# Extract first ESC...m sequence from a string (or empty if none)
_extract_escape() {
  local s="$1"
  # Leading sequence
  if [[ $s =~ ^($'\033''\[[0-9;]*m) ]]; then
    printf '%s' "${BASH_REMATCH[1]}"
    return 0
  fi
  # First sequence anywhere
  if [[ $s =~ ($'\033''\[[0-9;]*m) ]]; then
    printf '%s' "${BASH_REMATCH[1]}"
    return 0
  fi
  return 1
}

# Try to probe engine/palette outputs to get an actual escape sequence
STATUS_ESC=""
discover_status_escape() {
  STATUS_ESC=""

  # 1) If engine provides cml_colorize and C_GOOD, try that
  if declare -F cml_colorize >/dev/null 2>&1 && [ -n "${C_GOOD:-}" ]; then
    local out esc
    out=$(cml_colorize "X" "${C_GOOD}" 2>/dev/null || true)
    esc=$(_extract_escape "$out" 2>/dev/null || true)
    [ -n "$esc" ] && { STATUS_ESC="$esc"; return 0; }
  fi

  # 2) Try a set of palette vars through cml_colorize or literal var content
  for var in C_ACCENT C_TITLE C_INFO C_SYMBOL C_GOOD; do
    if declare -F cml_colorize >/dev/null 2>&1 && [ -n "${!var:-}" ]; then
      out=$(cml_colorize "X" "${!var}" 2>/dev/null || true)
      esc=$(_extract_escape "$out" 2>/dev/null || true)
      [ -n "$esc" ] && { STATUS_ESC="$esc"; return 0; }
    fi
    if [ -n "${!var:-}" ]; then
      esc=$(_extract_escape "${!var}" 2>/dev/null || true)
      [ -n "$esc" ] && { STATUS_ESC="$esc"; return 0; }
    fi
  done

  # 3) If vars were hex like #RRGGBB, try to convert -> rgb escape (if function exists)
  for var in C_GOOD C_ACCENT C_TITLE; do
    local val="${!var:-}"
    if [[ $val =~ ^#([A-Fa-f0-9]{6})$ ]] && declare -F hex_to_rgb >/dev/null 2>&1; then
      local rgb out esc r g b
      rgb=$(hex_to_rgb "$val" 2>/dev/null || true)
      if [ -n "$rgb" ]; then
        set -- $rgb
        r=$1; g=$2; b=$3
        if declare -F rgb_fg >/dev/null 2>&1; then
          out=$(rgb_fg "$r" "$g" "$b" "X" 2>/dev/null || true)
          esc=$(_extract_escape "$out" 2>/dev/null || true)
          [ -n "$esc" ] && { STATUS_ESC="$esc"; return 0; }
        else
          # construct standard 24-bit escape
          STATUS_ESC=$'\033[38;2;'"${r};${g};${b}m"
          return 0
        fi
      fi
    fi
  done

  # 4) Nothing discovered ‚Äî leave empty (caller will fallback)
  STATUS_ESC=""
  return 1
}

# Theme reading
if [ -f "$THEME_FILE" ]; then
  CURRENT_THEME=$(<"$THEME_FILE")
  CURRENT_THEME="${CURRENT_THEME//[$'\r\n']/}"
  CURRENT_THEME="${CURRENT_THEME^^}"
else
  CURRENT_THEME="CLASSIC"
  printf "%s" "$CURRENT_THEME" > "$THEME_FILE"
fi

# Try to load palette if engine provides loader
PALETTE_OK=false
if declare -F cml_load_palette >/dev/null 2>&1; then
  if cml_load_palette "$CURRENT_THEME"; then
    PALETTE_OK=true
  fi
fi

# Now try to discover an escape from engine/palette
discover_status_escape || STATUS_ESC=""

# If nothing discovered, DO a deterministic fallback based on theme name suffix.
# This ensures "NEON:RED" will produce a neon red, "NEON:YELLOW" neon yellow etc.
if [ -z "$STATUS_ESC" ]; then
  # extract the suffix after colon (e.g. NEON:RED -> RED)
  theme_suffix="${CURRENT_THEME#*:}"
  theme_suffix="${theme_suffix^^}"
  case "$theme_suffix" in
    RED)
      R=255; G=40; B=120 ;;    # neon/magenta-red
    GREEN)
      R=0; G=255; B=120 ;;     # neon green
    BLUE)
      R=30; G=144; B=255 ;;    # dodger-like blue
    YELLOW)
      R=255; G=210; B=0 ;;
    PURPLE)
      R=200; G=70; B=255 ;;
    ORANGE)
      R=255; G=130; B=20 ;;
    PINK)
      R=255; G=80; B=180 ;;
    *)
      # default neon green
      R=0; G=255; B=120 ;;
  esac
  # Use rgb escape directly (safe)
  STATUS_ESC=$'\033[38;2;'"${R};${G};${B}m"
fi

# Header (compact)
cols=$(tput cols 2>/dev/null || printf '%s' "${COLUMNS:-80}")
[ -z "$cols" ] && cols=80
[ "$cols" -lt 40 ] && cols=80
border_w=$(( cols * 75 / 100 ))
[ "$border_w" -lt 40 ] && border_w=40

# Print a neat header
printf "%b\n" "${STATUS_ESC}$(_repeat "$border_w" '‚ïê')${C_RESET}"
printf "%b\n" "${STATUS_ESC}‚úî CML TRUECOLOR ENGINE LOADED (${CML_TRUECOLOR_VERSION:-${CML_TRUECOLOR:-UNKNOWN}})${C_RESET}"
printf "%b\n" "${STATUS_ESC}COLOR MASTER LIBRARY (CML) GENERAL TEST${C_RESET}"
printf "%b\n" "${STATUS_ESC}$(_repeat "$border_w" '‚ïê')${C_RESET}"

# Version & engine info (use readable colors)
printf "%b\n" "$(_extract_escape "$(cml_colorize "CML VERSION: ${CML_VERSION}" "${C_RESET}" 2>/dev/null || echo "")" 2>/dev/null || printf '\033[255;105;180m')CML VERSION: ${CML_VERSION}${C_RESET}"
if declare -F cml_colorize >/dev/null 2>&1; then
  printf "%b\n" "$(cml_colorize "TRUECOLOR ENGINE: ${CML_TRUECOLOR_VERSION:-${CML_TRUECOLOR:-UNKNOWN}}" "${C_RESET}")"
else
  printf "%b\n" "TRUECOLOR ENGINE: ${CML_TRUECOLOR_VERSION:-${CML_TRUECOLOR:-UNKNOWN}}"
fi
printf "%b\n" "${C_RESET}TEST STARTED: $(date)${C_RESET}"
printf "\n"

# [1] Engine tests
printf "%b\n" "${C_RESET}[1] ENGINE INTEGRITY TEST${C_RESET}"
if declare -F rgb_fg >/dev/null 2>&1 && declare -F rgb_bg >/dev/null 2>&1; then
  printf "%b\n" "${STATUS_ESC}‚úî ENGINE FUNCTIONS DETECTED${C_RESET}"
  printf "%b\n" "${STATUS_ESC}‚úî TRUECOLOR SUPPORT DETECTED${C_RESET}"
else
  printf "%b\n" "${STATUS_ESC}‚úî ENGINE FUNCTIONS DETECTED (partial)${C_RESET}"
fi
printf "\n"

# [2] Theme file validation
printf "%b\n" "${C_RESET}[2] THEME FILE VALIDATION${C_RESET}"
printf "%b\n" "${STATUS_ESC}‚úî ACTIVE THEME: ${CURRENT_THEME}${C_RESET}"
printf "\n"

# [3] RGB / HEX / FALLBACK TESTS
printf "%b\n" "${C_RESET}[3] RGB / HEX / FALLBACK TESTS${C_RESET}"
printf "\n  GRADIENT DEMO\n\n"
# show small colored blocks using rgb_bg if available; otherwise key text
if declare -F rgb_bg >/dev/null 2>&1; then
  for r in 0 64 128 192 255; do
    # print a small block then reset
    printf "%b" "$(rgb_bg "$r" 0 128) ${C_RESET}"
  done
  printf "\n"
  for r in 0 64 128 192 255; do
    printf " %3d " "$r"
  done
  printf "\n\n"
else
  printf " (no rgb_bg available)\n\n"
fi

HEX="#1E90FF"
HEX_RGB="$(hex_to_rgb "$HEX" 2>/dev/null || true)"
if [ -n "$HEX_RGB" ]; then
  printf "%b\n" "${C_RESET}HEX ‚Üí RGB (${HEX}): ${HEX_RGB}${C_RESET}"
  if declare -F rgb_fg >/dev/null 2>&1; then
    set -- $HEX_RGB
    printf "%b\n" "$(rgb_fg "$1" "$2" "$3" "THIS LINE USES THE EXACT HEX COLOR AS FOREGROUND")${C_RESET}"
  else
    printf "%b\n" "THIS LINE USES THE EXACT HEX COLOR AS FOREGROUND"
  fi
else
  printf "%b\n" "${C_RESET}HEX ‚Üí RGB (${HEX}): (failed)${C_RESET}"
fi

FALLBACK3="$(cml_fallback_color 3 2>/dev/null || true)"
if [ -n "$FALLBACK3" ]; then
  printf "%b\n" "${C_RESET}FALLBACK COLOR [3]: ${FALLBACK3}${C_RESET}"
else
  printf "%b\n" "${C_RESET}FALLBACK COLOR [3]: (empty)${C_RESET}"
fi

printf "\n"

# [4] Palette load
printf "%b\n" "${C_RESET}[4] PALETTE LOAD TEST${C_RESET}"
if declare -F cml_load_palette >/dev/null 2>&1 && cml_load_palette "$CURRENT_THEME"; then
  # re-discover in case the engine updated internal state
  discover_status_escape || true
  printf "%b\n" "${STATUS_ESC}‚úî PALETTE LOADED FOR: ${CURRENT_THEME}${C_RESET}"
else
  printf "%b\n" "${STATUS_ESC}‚ùå PALETTE LOAD FAILED FOR: ${CURRENT_THEME}${C_RESET}"
fi

printf "\n"

# [5] Colorize & title test
printf "%b\n" "${C_RESET}[5] COLORIZE & TITLE TEST${C_RESET}"
if declare -F cml_title >/dev/null 2>&1; then
  cml_title "CML COLORIZED TITLE SAMPLE"
else
  printf "%b\n" "${STATUS_ESC}CML COLORIZED TITLE SAMPLE${C_RESET}"
fi

# Lines colored by palette if available; fallbacks otherwise
if [ -n "${C_INFO:-}" ]; then
  if declare -F cml_colorize >/dev/null 2>&1; then
    printf "%b\n" "$(cml_colorize "INFO LINE" "${C_INFO}")"
  else
    printf "%b\n" "INFO LINE"
  fi
else
  printf "%b\n" "INFO LINE"
fi

if [ -n "${C_GOOD:-}" ]; then
  printf "%b\n" "${STATUS_ESC}SUCCESS LINE${C_RESET}"
else
  printf "%b\n" "SUCCESS LINE"
fi

if [ -n "${C_BAD:-}" ]; then
  printf "%b\n" "${C_BAD}ERROR LINE${C_RESET}"
else
  printf "%b\n" "ERROR LINE"
fi

if [ -n "${C_SYMBOL:-}" ]; then
  if declare -F cml_colorize >/dev/null 2>&1; then
    printf "%b\n" "$(cml_colorize "SYMBOL TEST" "${C_SYMBOL}")"
  else
    printf "%b\n" "SYMBOL TEST"
  fi
else
  printf "%b\n" "SYMBOL TEST"
fi

printf "\n"

# [6] Theme visual demo
printf "%b\n" "${C_RESET}[6] THEME VISUAL DEMO${C_RESET}"
# Use status escape for the "Sample TITLE" to guarantee visible theme association
printf "%b\n" "${STATUS_ESC}Sample TITLE${C_RESET}"
printf "%b\n" "${STATUS_ESC}Sample INFO${C_RESET}"
printf "%b\n" "${STATUS_ESC}Sample GOOD${C_RESET}"
printf "%b\n" "${STATUS_ESC}Sample WARN${C_RESET}"
printf "%b\n" "${STATUS_ESC}Sample BAD${C_RESET}"
printf "%b\n" "${STATUS_ESC}Sample SYMBOL${C_RESET}"

printf "\n"

# Final consistent lines (all use STATUS_ESC)
printf "%b\n" "${STATUS_ESC}‚úî DEMO FINISHED.${C_RESET}"
printf "%b\n" "${STATUS_ESC}üé® ACTIVE THEME: ${CURRENT_THEME}${C_RESET}"
printf "\n"

# Footer
printf "%b\n" "${C_RESET}$(_repeat "$border_w" '‚ïê')${C_RESET}"
printf "%b\n" "${STATUS_ESC}‚úî CML GENERAL TEST HARNESS FINISHED.${C_RESET}"
printf "%b\n" "${C_RESET}RUN DATE: $(date)${C_RESET}"
printf "%b\n" "${C_RESET}$(_repeat "$border_w" '‚ïê')${C_RESET}"

exit 0

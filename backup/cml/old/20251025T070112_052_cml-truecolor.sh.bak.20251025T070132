#!/usr/bin/env bash
# ==========================================================
# FILE: ~/kh-scripts/library/colors/cml-truecolor.sh
# TITLE: CML TrueColor Engine
# VERSION: v1.6.2-safeprintf
# NOTE: Safe printf usage and robust hex/rgb parsing.
# ==========================================================
set -u

CML_TRUECOLOR_VERSION="v1.6.2-safeprintf"
CML_DIR="${HOME:-$HOME}/kh-scripts/library/colors"
BACKUP_DIR="${HOME:-$HOME}/kh-scripts/backup"
ENGINE_PATH="$CML_DIR/cml-truecolor.sh"

# Backup existing copy (non-destructive)
mkdir -p "$BACKUP_DIR" 2>/dev/null || true
if [ -f "$ENGINE_PATH" ]; then
  ts=$(date +"%Y%m%dT%H%M%S" 2>/dev/null || printf "%s" "$(date +%s)")
  cp -p "$ENGINE_PATH" "$BACKUP_DIR/cml-truecolor.sh.bak.$ts" 2>/dev/null || true
fi

# ---------- ESC / RESET ----------
ESC=$'\e'
CML_RESET="${CML_RESET:-$ESC[0m}"

# ---------- TRUECOLOR DETECTION ----------
cml_truecolor_supported() {
  # Prefer COLORTERM hints; fall back to TERM heuristics
  local ct="${COLORTERM:-}"
  local term="${TERM:-}"
  if [[ "$ct" =~ truecolor|24bit ]]; then
    return 0
  fi
  if [[ "$term" =~ -256color$ || "$term" =~ truecolor ]]; then
    return 0
  fi
  return 1
}

# ---------- SAFE RGB OUTPUT ----------
# rgb_fg and rgb_bg accept 3 args; missing args default to 0
# Use printf with %b to avoid -e portability issues; always produce real ESC sequences.
rgb_fg() {
  # usage: rgb_fg R G B
  local r="${1:-0}"; local g="${2:-0}"; local b="${3:-0}"
  # sanitize non-integers: use arithmetic expansion fallback to 0
  case "$r" in ''|*[!0-9]*) r=0 ;; esac
  case "$g" in ''|*[!0-9]*) g=0 ;; esac
  case "$b" in ''|*[!0-9]*) b=0 ;; esac
  printf "%b" "${ESC}[38;2;${r};${g};${b}m"
}

rgb_bg() {
  local r="${1:-0}"; local g="${2:-0}"; local b="${3:-0}"
  case "$r" in ''|*[!0-9]*) r=0 ;; esac
  case "$g" in ''|*[!0-9]*) g=0 ;; esac
  case "$b" in ''|*[!0-9]*) b=0 ;; esac
  printf "%b" "${ESC}[48;2;${r};${g};${b}m"
}

# ---------- SAFE HEX -> RGB PARSER ----------
# hex_to_rgb "#RRGGBB" or "RRGGBB" -> "R G B"
hex_to_rgb() {
  local hx="${1:-}"
  hx="${hx##\#}"        # strip leading # if present
  # if empty or invalid length, return safe defaults
  if [[ -z "$hx" || ! "$hx" =~ ^[0-9A-Fa-f]{6}$ ]]; then
    printf "%d %d %d" 0 0 0
    return 0
  fi
  # safe extraction with 16# conversion guarded by regex already
  local r=$((16#${hx:0:2}))
  local g=$((16#${hx:2:2}))
  local b=$((16#${hx:4:2}))
  printf "%d %d %d" "$r" "$g" "$b"
  return 0
}

# ---------- UNIFIED RESET ----------
cml_reset_color() {
  printf "%b" "$CML_RESET"
}

# ---------- THEME PALETTE LOADER (adds GRAD_START / GRAD_END) ----------
# Keep themes simple and extensible. Themes must set C_HEADER, C_INFO, etc.
cml_load_palette() {
  local theme="${1:-CLASSIC}"
  theme="${theme^^}"
  case "$theme" in
    NEON:ORANGE|NEON_ORANGE|NEONORANGE)
      C_HEADER="#FF8C00"   # orange
      C_INFO="#FFD700"     # gold
      C_SYMBOL="#FFA07A"
      C_WARNING="#FFA500"
      C_ERROR="#FF0033"
      C_SUCCESS="#32FF7A"
      C_ACCENT="#33CCFF"
      GRAD_START="#FF8C00"
      GRAD_END="#FFD580"
      ;;
    NEON:PURPLE|NEON_PURPLE|NEONPURPLE)
      C_HEADER="#B452FF"
      C_INFO="#E0B3FF"
      C_SYMBOL="#FFB3E6"
      C_WARNING="#D18CFF"
      C_ERROR="#FF66CC"
      C_SUCCESS="#A0FFB3"
      C_ACCENT="#66CCFF"
      GRAD_START="#9A4DFF"
      GRAD_END="#E0B3FF"
      ;;
    OCEAN)
      C_HEADER="#007FFF"
      C_INFO="#66CCFF"
      C_SYMBOL="#00B3CC"
      C_WARNING="#66E0FF"
      C_ERROR="#0066CC"
      C_SUCCESS="#33FFCC"
      C_ACCENT="#66FFFF"
      GRAD_START="#007FFF"
      GRAD_END="#66CCFF"
      ;;
    FOREST)
      C_HEADER="#2E8B57"
      C_INFO="#8FD9A6"
      C_SYMBOL="#4CA64C"
      C_WARNING="#7ACB73"
      C_ERROR="#2E8B57"
      C_SUCCESS="#9BFFB3"
      C_ACCENT="#66CC99"
      GRAD_START="#228B22"
      GRAD_END="#A8E6A3"
      ;;
    CLASSIC|*)
      C_HEADER="#FFFFFF"
      C_INFO="#C0C0C0"
      C_SYMBOL="#A0A0A0"
      C_WARNING="#FFFF00"
      C_ERROR="#FF0000"
      C_SUCCESS="#00FF00"
      C_ACCENT="#00AFFF"
      GRAD_START="#AAAAAA"
      GRAD_END="#FFFFFF"
      ;;
  esac
  # Export variables for other scripts that source this file
  export C_HEADER C_INFO C_SYMBOL C_WARNING C_ERROR C_SUCCESS C_ACCENT GRAD_START GRAD_END
  return 0
}

# Ensure default palette loaded
: "${CURRENT_THEME:=${CURRENT_THEME:-CLASSIC}}"
cml_load_palette "${CURRENT_THEME:-CLASSIC}" >/dev/null 2>&1 || true

# ---------- GRADIENT HELPERS ----------
# Interpolate two integers safely
_interp_int() {
  # args: a b idx steps
  local a="$1" b="$2" idx="$3" steps="$4"
  if [ "$steps" -le 1 ]; then
    printf "%d" "$a"
    return
  fi
  # integer interpolation without floating point (safe)
  printf "%d" $(( (a*(steps-1-idx) + b*idx) / (steps-1) ))
}

# cml_apply_theme_gradient "text"
# Apply a gradient from GRAD_START -> GRAD_END across the text characters.
cml_apply_theme_gradient() {
  local text="$1"
  # fallback if no gradient defined
  local gs="${GRAD_START:-#AAAAAA}"
  local ge="${GRAD_END:-#FFFFFF}"
  # get rgb anchors
  read -r sr sg sb <<<"$(hex_to_rgb "${gs#\#}")"
  read -r er eg eb <<<"$(hex_to_rgb "${ge#\#}")"
  local len=${#text}
  # protect zero-length
  if [ "$len" -le 0 ]; then
    printf "%s\n" "$text"
    return 0
  fi
  local i r g b ch seq
  for ((i=0;i<len;i++)); do
    ch="${text:i:1}"
    r=$(_interp_int "$sr" "$er" "$i" "$len")
    g=$(_interp_int "$sg" "$eg" "$i" "$len")
    b=$(_interp_int "$sb" "$eb" "$i" "$len")
    seq="$(rgb_fg "$r" "$g" "$b")"
    printf "%b%s" "$seq" "$ch"
  done
  cml_reset_color
  printf "\n"
  return 0
}

# cml_render_gradient_bar WIDTH
# Renders a horizontal bar of block characters using theme gradient.
cml_render_gradient_bar() {
  local width="${1:-40}"
  # clamp width to reasonable numbers
  if ! [[ "$width" =~ ^[0-9]+$ ]]; then width=40; fi
  if [ "$width" -lt 4 ]; then width=4; fi
  local gs="${GRAD_START:-#AAAAAA}"
  local ge="${GRAD_END:-#FFFFFF}"
  local steps="$width"
  read -r sr sg sb <<<"$(hex_to_rgb "${gs#\#}")"
  read -r er eg eb <<<"$(hex_to_rgb "${ge#\#}")"
  local i r g b
  for ((i=0;i<steps;i++)); do
    r=$(_interp_int "$sr" "$er" "$i" "$steps")
    g=$(_interp_int "$sg" "$eg" "$i" "$steps")
    b=$(_interp_int "$sb" "$eb" "$i" "$steps")
    printf "%bâ–ˆ" "$(rgb_fg "$r" "$g" "$b")"
  done
  cml_reset_color
  printf "\n"
  return 0
}

# ---------- BACKWARD-COMPAT WRAPPERS ----------
# Some scripts expect to call legacy function names that return escapes directly.
# Keep wrappers that produce escape sequences for single-color roles, by reading C_* variables.
to_fg_seq() {
  local v="${1:-}"
  if [[ "$v" =~ ^#?[0-9A-Fa-f]{6}$ ]]; then
    read -r r g b <<<"$(hex_to_rgb "${v#\#}")"
    rgb_fg "$r" "$g" "$b"
  else
    # if the value already contains ESC, print as is, otherwise fall back to white
    if printf '%s' "$v" | grep -q $'\e' 2>/dev/null; then
      printf "%s" "$v"
    else
      rgb_fg 255 255 255
    fi
  fi
}

# ---------- EXPORTS (functions that other scripts may call) ----------
export -f cml_truecolor_supported rgb_fg rgb_bg hex_to_rgb cml_reset_color cml_load_palette cml_apply_theme_gradient cml_render_gradient_bar to_fg_seq

# END OF FILE

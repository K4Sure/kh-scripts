#!/usr/bin/env bash
# File: $HOME/kh-scripts/bup
# Purpose: Globally callable backup helper ("bup") with branded emoji, TrueColor feedback, progress bar, and clean summary


SCRIPT_VERSION="v1.5.3"


# --- Color palette (CML TrueColor) ---
CLR_OK=$'\e[38;2;0;200;0m'        # green
CLR_WARN=$'\e[38;2;255;200;0m'    # yellow
CLR_ERR=$'\e[38;2;220;0;0m'       # red
CLR_INFO=$'\e[38;2;120;160;255m'  # light blue (muted)
CLR_BACKUP=$'\e[38;2;0;180;220m'  # cyan (accent2)
CLR_RESET=$'\e[0m'



# ===============================================================
# PROGRESS BAR (no external deps)
# ===============================================================
PB_TOTAL=0
PB_CURRENT=0
PB_START=0


progress_init() {
  PB_TOTAL=$1
  PB_CURRENT=0
  PB_START=$(date +%s)

  # handle zero-case
  if [ "$PB_TOTAL" -le 0 ]; then
    printf "\n===== BASH BACKUP SCRIPT %s =====\n\n" "$SCRIPT_VERSION"
    printf "${CLR_INFO}‚ÑπÔ∏è No files to back up${CLR_RESET}\n\n"
    return 1
  fi

  # header (with airy spacing)
  printf "\n===== BASH BACKUP SCRIPT %s =====\n\n" "$SCRIPT_VERSION"
  return 0
}


progress_update() {
  PB_CURRENT=$((PB_CURRENT+1))
  progress_render
}


progress_render() {
  local now elapsed pct width fill_len empty_len eta eta_min eta_sec eta_str pct_disp full

  now=$(date +%s)
  elapsed=$((now - PB_START))
  [ $elapsed -le 0 ] && elapsed=1

  # percentage as float string
  pct=$(awk -v c=$PB_CURRENT -v t=$PB_TOTAL 'BEGIN {printf "%.4f", (t>0 ? c/t : 0)}')

  # terminal width and bar segments
  width=$(tput cols 2>/dev/null || echo 80)
  width=$((width - 50))
  [ $width -lt 30 ] && width=30

  fill_len=$(awk -v w=$width -v p=$pct 'BEGIN {printf "%d", w*p}')
  empty_len=$((width - fill_len))

  # are we full?
  full=0
  [ "$PB_CURRENT" -ge "$PB_TOTAL" ] && full=1

  # segments
  local filled empty divider bar

  if [ "$fill_len" -gt 0 ]; then
    filled="${CLR_BACKUP}$(printf '‚îÅ%.0s' $(seq 1 $fill_len 2>/dev/null))${CLR_RESET}"
  else
    filled=""
  fi

  if [ "$empty_len" -gt 0 ]; then
    empty="${CLR_INFO}$(printf '‚îÄ%.0s' $(seq 1 $empty_len 2>/dev/null))${CLR_RESET}"
  else
    empty=""
  fi

  divider=""
  if [ $full -eq 0 ] && [ $fill_len -lt $width ]; then
    divider="${CLR_OK}‚ï∏${CLR_RESET}"
  fi

  bar="${filled}${divider}${empty}"

  # ETA (force 00:00 at full)
  if [ $full -eq 1 ]; then
    eta=0
  else
    eta=$(( (PB_TOTAL - PB_CURRENT) * elapsed / (PB_CURRENT>0?PB_CURRENT:1) ))
    [ $eta -lt 0 ] && eta=0
  fi
  eta_min=$((eta/60))
  eta_sec=$((eta%60))
  eta_str=$(printf "%02d:%02d" $eta_min $eta_sec)

  # percent display (one decimal, force 100.0% when full)
  if [ $full -eq 1 ]; then
    pct_disp="100.0"
  else
    pct_disp=$(awk -v p=$pct 'BEGIN {printf "%5.1f", p*100}')
  fi

  # overwrite same line
  printf "\r${CLR_OK}%3d${CLR_RESET}/${CLR_INFO}%d${CLR_RESET} [%s] ${CLR_OK}%s%%%s ETA ${CLR_INFO}%s${CLR_RESET}" \
    "$PB_CURRENT" "$PB_TOTAL" "$bar" "$pct_disp" "" "$eta_str"
}


# Finalize: force 100% render and newline
progress_finish() {
  PB_CURRENT="$PB_TOTAL"
  progress_render
  echo
}



# ===============================================================
# BACKUP LOGIC
# ===============================================================
backup_one() {
  local src="$1"
  local provided_lib="$2"
  local SRC_ROOT="$HOME/kh-scripts"
  local BK_ROOT="$HOME/kh-scripts/backup"

  # SAFETY GUARD
  case "$src" in
    "$BK_ROOT"|"$BK_ROOT"/*)
      # keep errors minimal to preserve single-line progress UX
      return 5
      ;;
  esac

  mkdir -p "$BK_ROOT"

  local fn parent lowerfn lowerparent lib
  fn="$(basename -- "$src")"
  parent="$(basename "$(dirname "$src")")"
  lowerfn="${fn,,}"
  lowerparent="${parent,,}"
  lib="${provided_lib:-}"

  # Library detection
  if [ -z "$lib" ]; then
    case "$lowerfn" in
      cml|truecolor|colormaster ) lib="cml" ;;
      dbml|dynamicbox|box        ) lib="dbml" ;;
      csml|symbol|characters     ) lib="csml" ;;
      pml|parallel               ) lib="pml"  ;;
      *)
        case "$lowerparent" in
          cml) lib="cml" ;;
          dbml) lib="dbml" ;;
          csml) lib="csml" ;;
          pml) lib="pml"  ;;
          *)   lib=""     ;;
        esac
      ;;
    esac
  fi

  # Ensure dirs
  if [ -n "$lib" ]; then
    mkdir -p "$BK_ROOT/$lib" "$BK_ROOT/$lib/old" "$BK_ROOT/$lib/archive"
  else
    mkdir -p "$BK_ROOT" "$BK_ROOT/old"
  fi

  # Extract SCRIPT_VERSION (first 120 lines)
  local script_version
  script_version="$(sed -n '1,120p' -- "$src" 2>/dev/null | sed -n 's/^[[:space:]]*SCRIPT_VERSION[[:space:]]*=[[:space:]]*["'\'']\(v[0-9]\+\.[0-9]\+\.[0-9]\+\)["'\'']/\1/p' | head -n1 || true)"

  # Determine backup filename
  local target
  if printf '%s' "$fn" | grep -Eq '[_-]v[0-9]+\.[0-9]+\.[0-9]+'; then
    local ts; ts=$(date '+%Y%m%d_%H%M')
    target="${fn}_${ts}.backup"
  else
    if [ -n "$script_version" ]; then
      target="${fn}_${script_version}.backup"
    else
      local ds; ds=$(date '+%Y%m%d_%H%M')
      target="${fn}_${ds}.backup"
    fi
  fi

  # Destination
  local dest
  if [ -n "$lib" ]; then
    dest="$BK_ROOT/$lib/$target"
  else
    dest="$BK_ROOT/$target"
  fi

  # Handle collisions
  if [ -e "$dest" ]; then
    if [ -n "$lib" ]; then
      mv -n -- "$dest" "$BK_ROOT/$lib/old/" 2>/dev/null || {
        local nowts; nowts=$(date '+%Y%m%d_%H%M')
        mv -- "$dest" "$BK_ROOT/$lib/old/${target}.${nowts}" || true
      }
    else
      mv -n -- "$dest" "$BK_ROOT/old/" 2>/dev/null || {
        local nowts; nowts=$(date '+%Y%m%d_%H%M')
        mv -- "$dest" "$BK_ROOT/old/${target}.${nowts}" || true
      }
    fi
  fi

  # Copy (silent on success)
  cp -p -- "$src" "$dest"
}



backup_script() {
  local input="$1"
  local provided_lib="$2"
  local SRC_ROOT="$HOME/kh-scripts"
  local BK_ROOT="$HOME/kh-scripts/backup"

  [ -n "$input" ] || {
    printf "\n===== BASH BACKUP SCRIPT %s =====\n\n" "$SCRIPT_VERSION"
    echo "${CLR_INFO}‚ÑπÔ∏è Usage:${CLR_RESET} bup <file-or-folder> [library]"
    echo
    return 2
  }

  local src="$input"
  if [ ! -e "$src" ]; then
    if [ -e "$SRC_ROOT/$input" ]; then
      src="$SRC_ROOT/$input"
    else
      printf "\n===== BASH BACKUP SCRIPT %s =====\n\n" "$SCRIPT_VERSION"
      echo "${CLR_ERR}‚ùå Not found:${CLR_RESET} $input or $SRC_ROOT/$input"
      echo
      return 3
    fi
  fi

  # SAFETY GUARD for input
  case "$src" in
    "$BK_ROOT"|"$BK_ROOT"/*)
      printf "\n===== BASH BACKUP SCRIPT %s =====\n\n" "$SCRIPT_VERSION"
      echo "${CLR_WARN}‚ö†Ô∏è Refusing to back up the backup folder or its contents:${CLR_RESET} $src"
      echo
      return 6
      ;;
  esac

  if [ -f "$src" ]; then
    progress_init 1 || return 0

    backup_one "$src" "$provided_lib"
    progress_update
    progress_finish

    # Summary (as requested)
    echo
    echo -e "${CLR_BACKUP}üì¶ 1 Files Backed Up @ ${CLR_RESET}$HOME/kh-scripts/backup"
    echo
    return 0

  elif [ -d "$src" ]; then
    local total_files processed dest_dir lib_candidate

    total_files=$(find "$src" -maxdepth 1 -type f | wc -l)
    total_files=${total_files//[[:space:]]/}

    progress_init "$total_files" || return 0

    processed=0
    for f in "$src"/*; do
      [ -f "$f" ] || continue
      backup_one "$f" "$provided_lib" && processed=$((processed+1))
      progress_update
    done

    progress_finish

    # Destination preview (best-effort)
    local fn parent lowerfn lowerparent
    fn="$(basename -- "$src")"
    parent="$(basename "$(dirname "$src")")"
    lowerfn="${fn,,}"
    lowerparent="${parent,,}"
    lib_candidate="${provided_lib:-}"

    if [ -z "$lib_candidate" ]; then
      case "$lowerfn" in
        cml|truecolor|colormaster ) lib_candidate="cml" ;;
        dbml|dynamicbox|box        ) lib_candidate="dbml" ;;
        csml|symbol|characters     ) lib_candidate="csml" ;;
        pml|parallel               ) lib_candidate="pml"  ;;
        *)
          case "$lowerparent" in
            cml) lib_candidate="cml" ;;
            dbml) lib_candidate="dbml" ;;
            csml) lib_candidate="csml" ;;
            pml) lib_candidate="pml"  ;;
            *)   lib_candidate=""     ;;
          esac
        ;;
      esac
    fi

    if [ -n "$lib_candidate" ]; then
      dest_dir="$BK_ROOT/$lib_candidate"
    else
      dest_dir="$BK_ROOT"
    fi

    # Summary (as requested)
    echo
    echo -e "${CLR_BACKUP}üì¶ ${processed} Files Backed Up @ ${CLR_RESET}$HOME/kh-scripts/backup"
    echo
    return 0

  else
    printf "\n===== BASH BACKUP SCRIPT %s =====\n\n" "$SCRIPT_VERSION"
    echo "${CLR_ERR}‚ùå Unsupported type:${CLR_RESET} $src"
    echo
    return 4
  fi
}



# Entry point
backup_script "$@"

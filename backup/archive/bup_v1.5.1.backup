#!/usr/bin/env bash
# File: /data/data/com.termux/files/home/kh-scripts/bup
# Purpose: Globally callable backup helper ("bup") with branded emoji, TrueColor feedback, progress bar, and final summary

SCRIPT_VERSION="v1.5.1"

# --- Color palette (CML TrueColor) ---
CLR_OK=$'\e[38;2;0;200;0m'        # green
CLR_WARN=$'\e[38;2;255;200;0m'    # yellow
CLR_ERR=$'\e[38;2;220;0;0m'       # red
CLR_INFO=$'\e[38;2;120;160;255m'  # light blue (muted)
CLR_BACKUP=$'\e[38;2;0;180;220m'  # cyan (accent2)
CLR_RESET=$'\e[0m'

# ===============================================================
# PROGRESS BAR (no external deps)
# ===============================================================
PB_TOTAL=0
PB_CURRENT=0
PB_START=0

progress_init() {
  PB_TOTAL=$1
  PB_CURRENT=0
  PB_START=$(date +%s)
  # handle zero-case: print a tiny bar and return
  [ "$PB_TOTAL" -le 0 ] && {
    printf "${CLR_INFO}‚ÑπÔ∏è No files to back up${CLR_RESET}\n"
    return 1
  }
  return 0
}

progress_update() {
  PB_CURRENT=$((PB_CURRENT+1))
  progress_render
}

progress_render() {
  local now elapsed pct width fill_len empty_len eta eta_min eta_sec eta_str
  now=$(date +%s)
  elapsed=$((now - PB_START))
  [ $elapsed -le 0 ] && elapsed=1

  pct=$(awk -v c=$PB_CURRENT -v t=$PB_TOTAL 'BEGIN {printf "%.4f", (t>0 ? c/t : 0)}')

  width=$(tput cols 2>/dev/null || echo 80)
  width=$((width - 50))
  [ $width -lt 30 ] && width=30

  fill_len=$(awk -v w=$width -v p=$pct 'BEGIN {printf "%d", w*p}')
  empty_len=$((width - fill_len))

  local filled empty divider bar
  if [ "$fill_len" -gt 0 ]; then
    filled="${CLR_BACKUP}$(printf '‚îÅ%.0s' $(seq 1 $fill_len 2>/dev/null))${CLR_RESET}"
  else
    filled=""
  fi
  if [ "$empty_len" -gt 0 ]; then
    empty="${CLR_INFO}$(printf '‚îÄ%.0s' $(seq 1 $empty_len 2>/dev/null))${CLR_RESET}"
  else
    empty=""
  fi
  divider=""
  [ $fill_len -lt $width ] && divider="${CLR_OK}‚ï∏${CLR_RESET}"
  bar="${filled}${divider}${empty}"

  eta=$(( (PB_TOTAL - PB_CURRENT) * elapsed / (PB_CURRENT>0?PB_CURRENT:1) ))
  eta_min=$((eta/60))
  eta_sec=$((eta%60))
  eta_str=$(printf "%02d:%02d" $eta_min $eta_sec)

  # percent display (one decimal)
  pct_disp=$(awk -v p=$pct 'BEGIN {printf "%5.1f", p*100}')

  # overwrite same line
  printf "\r${CLR_OK}%3d${CLR_RESET}/${CLR_INFO}%d${CLR_RESET} [%s] ${CLR_OK}%s%%%s ETA ${CLR_INFO}%s${CLR_RESET}" \
    "$PB_CURRENT" "$PB_TOTAL" "$bar" "$pct_disp" "" "$eta_str"
}

progress_finish() {
  echo
}

# ===============================================================
# BACKUP LOGIC
# ===============================================================
backup_one() {
  local src="$1"
  local provided_lib="$2"
  local SRC_ROOT="/data/data/com.termux/files/home/kh-scripts"
  local BK_ROOT="/data/data/com.termux/files/home/kh-scripts/backup"

  # SAFETY GUARD
  case "$src" in
    "$BK_ROOT"|"$BK_ROOT"/*)
      echo "${CLR_WARN}‚ö†Ô∏è Refusing to back up files already inside the backup folder:${CLR_RESET} $src" >&2
      return 5
      ;;
  esac

  mkdir -p "$BK_ROOT"

  local fn parent lowerfn lowerparent lib
  fn="$(basename -- "$src")"
  parent="$(basename "$(dirname "$src")")"
  lowerfn="${fn,,}"
  lowerparent="${parent,,}"
  lib="${provided_lib:-}"

  # Library detection
  if [ -z "$lib" ]; then
    case "$lowerfn" in
      cml|truecolor|colormaster ) lib="cml" ;;
      dbml|dynamicbox|box ) lib="dbml" ;;
      csml|symbol|characters ) lib="csml" ;;
      pml|parallel ) lib="pml" ;;
      *)
        case "$lowerparent" in
          cml) lib="cml" ;;
          dbml) lib="dbml" ;;
          csml) lib="csml" ;;
          pml) lib="pml" ;;
          *) lib="" ;;
        esac
      ;;
    esac
  fi

  # Ensure dirs
  if [ -n "$lib" ]; then
    mkdir -p "$BK_ROOT/$lib" "$BK_ROOT/$lib/old" "$BK_ROOT/$lib/archive"
  else
    mkdir -p "$BK_ROOT" "$BK_ROOT/old"
  fi

  # Extract SCRIPT_VERSION (first 120 lines)
  local script_version
  script_version="$(sed -n '1,120p' -- "$src" 2>/dev/null | sed -n 's/^[[:space:]]*SCRIPT_VERSION[[:space:]]*=[[:space:]]*["'\'']\(v[0-9]\+\.[0-9]\+\.[0-9]\+\)["'\'']/\1/p' | head -n1 || true)"

  # Determine backup filename
  local target
  if printf '%s' "$fn" | grep -Eq '[_-]v[0-9]+\.[0-9]+\.[0-9]+'; then
    local ts; ts=$(date '+%Y%m%d_%H%M')
    target="${fn}_${ts}.backup"
  else
    if [ -n "$script_version" ]; then
      target="${fn}_${script_version}.backup"
    else
      local ds; ds=$(date '+%Y%m%d_%H%M')
      target="${fn}_${ds}.backup"
    fi
  fi

  # Destination
  local dest
  if [ -n "$lib" ]; then
    dest="$BK_ROOT/$lib/$target"
  else
    dest="$BK_ROOT/$target"
  fi

  # Handle collisions
  if [ -e "$dest" ]; then
    if [ -n "$lib" ]; then
      mv -n -- "$dest" "$BK_ROOT/$lib/old/" 2>/dev/null || {
        local nowts; nowts=$(date '+%Y%m%d_%H%M')
        mv -- "$dest" "$BK_ROOT/$lib/old/${target}.${nowts}" || true
      }
    else
      mv -n -- "$dest" "$BK_ROOT/old/" 2>/dev/null || {
        local nowts; nowts=$(date '+%Y%m%d_%H%M')
        mv -- "$dest" "$BK_ROOT/old/${target}.${nowts}" || true
      }
    fi
  fi

  # Copy (silent on success)
  if ! cp -p -- "$src" "$dest"; then
    echo "${CLR_ERR}‚ùå Backup failed for:${CLR_RESET} $src" >&2
    return 7
  fi

  return 0
}

backup_script() {
  local input="$1"
  local provided_lib="$2"
  local SRC_ROOT="/data/data/com.termux/files/home/kh-scripts"
  local BK_ROOT="/data/data/com.termux/files/home/kh-scripts/backup"

  [ -n "$input" ] || { echo "${CLR_INFO}‚ÑπÔ∏è Usage:${CLR_RESET} bup <file-or-folder> [library]" >&2; return 2; }

  local src="$input"
  if [ ! -e "$src" ]; then
    if [ -e "$SRC_ROOT/$input" ]; then
      src="$SRC_ROOT/$input"
    else
      echo "${CLR_ERR}‚ùå Not found:${CLR_RESET} $input or $SRC_ROOT/$input" >&2
      return 3
    fi
  fi

  # SAFETY GUARD for input
  case "$src" in
    "$BK_ROOT"|"$BK_ROOT"/*)
      echo "${CLR_WARN}‚ö†Ô∏è Refusing to back up the backup folder or its contents:${CLR_RESET} $src" >&2
      return 6
      ;;
  esac

  if [ -f "$src" ]; then
    progress_init 1 || return 0
    if backup_one "$src" "$provided_lib"; then
      progress_update
      progress_finish
      # final summary
      echo -e "${CLR_BACKUP}üì¶ BACKUP_CREATED:${CLR_RESET} $BK_ROOT/$(basename "$src")*.backup"
      echo -e "${CLR_OK}‚úÖ bup ${SCRIPT_VERSION}${CLR_RESET}"
      return 0
    else
      progress_finish
      return 1
    fi

  elif [ -d "$src" ]; then
    local total_files processed dest_dir lib final_count
    total_files=$(find "$src" -maxdepth 1 -type f | wc -l)
    total_files=${total_files//[[:space:]]/}
    progress_init "$total_files"
    # if no files, progress_init already printed info and returned 1 ‚Äî handle that
    if [ "$total_files" -le 0 ]; then
      return 0
    fi

    processed=0
    for f in "$src"/*; do
      [ -f "$f" ] || continue
      if backup_one "$f" "$provided_lib"; then
        processed=$((processed+1))
      fi
      progress_update
    done
    progress_finish

    # final summary line: count and destination hint (library-aware if consistent)
    # find library dir for source (best-effort)
    local fn parent lowerfn lowerparent lib_candidate
    fn="$(basename -- "$src")"
    parent="$(basename "$(dirname "$src")")"
    lowerfn="${fn,,}"
    lowerparent="${parent,,}"
    lib_candidate="${provided_lib:-}"
    if [ -z "$lib_candidate" ]; then
      case "$lowerfn" in
        cml|truecolor|colormaster ) lib_candidate="cml" ;;
        dbml|dynamicbox|box ) lib_candidate="dbml" ;;
        csml|symbol|characters ) lib_candidate="csml" ;;
        pml|parallel ) lib_candidate="pml" ;;
        *) 
          case "$lowerparent" in
            cml) lib_candidate="cml" ;;
            dbml) lib_candidate="dbml" ;;
            csml) lib_candidate="csml" ;;
            pml) lib_candidate="pml" ;;
            *) lib_candidate="" ;;
          esac
        ;;
      esac
    fi

    if [ -n "$lib_candidate" ]; then
      dest_dir="$BK_ROOT/$lib_candidate"
    else
      dest_dir="$BK_ROOT"
    fi

    echo -e "${CLR_BACKUP}üì¶ ${processed} backups created ‚Üí ${CLR_RESET}${dest_dir}/" 
    echo -e "${CLR_OK}‚úÖ bup ${SCRIPT_VERSION}${CLR_RESET}"
    return 0

  else
    echo "${CLR_ERR}‚ùå Unsupported type:${CLR_RESET} $src" >&2
    return 4
  fi
}

# Entry point
backup_script "$@"

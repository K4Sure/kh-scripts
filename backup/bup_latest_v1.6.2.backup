#!/usr/bin/env bash
# File: $HOME/kh-scripts/bup
# Purpose: Branded backup helper with TrueColor progress bar, archiving policy,
#          latest-copy sync to source, and clear failed-backup reporting (v1.6.2)

SCRIPT_VERSION="v1.6.2"

# --- Color palette (CML TrueColor) ---
CLR_OK=$'\e[38;2;0;200;0m'
CLR_WARN=$'\e[38;2;255;200;0m'
CLR_ERR=$'\e[38;2;220;0;0m'
CLR_INFO=$'\e[38;2;120;160;255m'
CLR_BACKUP=$'\e[38;2;0;180;220m'
CLR_SURPRISE=$'\e[38;2;255;100;200m'
CLR_RESET=$'\e[0m'

# Preferred emojis:
EMOJI_OK="üì¶"
EMOJI_FAIL_SUM="‚ùå"
EMOJI_FAIL_ITEM="‚ùó"

# ===============================
# PROGRESS BAR (no external deps)
# ===============================
PB_TOTAL=0
PB_CURRENT=0
PB_START=0

progress_init() {
  PB_TOTAL=$1
  PB_CURRENT=0
  PB_START=$(date +%s)

  if [ "$PB_TOTAL" -le 0 ]; then
    printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
    printf "${CLR_INFO}‚ÑπÔ∏è No files to back up${CLR_RESET}\n\n"
    return 1
  fi

  printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
  return 0
}

progress_update() {
  PB_CURRENT=$((PB_CURRENT+1))
  progress_render
}

progress_render() {
  local now elapsed pct width fill_len empty_len eta eta_min eta_sec eta_str pct_disp full

  now=$(date +%s)
  elapsed=$((now - PB_START))
  [ $elapsed -le 0 ] && elapsed=1

  pct=$(awk -v c=$PB_CURRENT -v t=$PB_TOTAL 'BEGIN {printf "%.4f", (t>0 ? c/t : 0)}')

  width=$(tput cols 2>/dev/null || echo 80)
  width=$((width - 50))
  [ $width -lt 30 ] && width=30

  fill_len=$(awk -v w=$width -v p=$pct 'BEGIN {printf "%d", w*p}')
  empty_len=$((width - fill_len))

  local filled empty divider bar full
  full=0
  [ "$PB_CURRENT" -ge "$PB_TOTAL" ] && full=1

  if [ "$fill_len" -gt 0 ]; then
    filled="${CLR_BACKUP}$(printf '‚îÅ%.0s' $(seq 1 $fill_len 2>/dev/null))${CLR_RESET}"
  else
    filled=""
  fi

  if [ "$empty_len" -gt 0 ]; then
    empty="${CLR_INFO}$(printf '‚îÄ%.0s' $(seq 1 $empty_len 2>/dev/null))${CLR_RESET}"
  else
    empty=""
  fi

  divider=""
  if [ $full -eq 0 ] && [ $fill_len -lt $width ]; then
    divider="${CLR_OK}‚ï∏${CLR_RESET}"
  fi
  bar="${filled}${divider}${empty}"

  if [ $full -eq 1 ]; then
    eta=0
  else
    eta=$(( (PB_TOTAL - PB_CURRENT) * elapsed / (PB_CURRENT>0?PB_CURRENT:1) ))
    [ $eta -lt 0 ] && eta=0
  fi
  eta_min=$((eta/60))
  eta_sec=$((eta%60))
  eta_str=$(printf "%02d:%02d" $eta_min $eta_sec)

  if [ $full -eq 1 ]; then
    pct_disp="100.0"
  else
    pct_disp=$(awk -v p=$pct 'BEGIN {printf "%5.1f", p*100}')
  fi

  printf "\r${CLR_OK}%3d${CLR_RESET}/${CLR_INFO}%d${CLR_RESET} [%s] ${CLR_OK}%s%%%s ETA ${CLR_INFO}%s${CLR_RESET}" \
    "$PB_CURRENT" "$PB_TOTAL" "$bar" "$pct_disp" "" "$eta_str"
}

progress_finish() {
  PB_CURRENT="$PB_TOTAL"
  progress_render
  echo
}

# ==========================
# HELPERS: detection & paths
# ==========================
detect_lib_from_name() {
  local fn_lower="$1"
  case "$fn_lower" in
    cml*|*truecolor*|*colormaster*) echo "cml" ;;
    dbml*|*dynamicbox*|*box*)       echo "dbml" ;;
    csml*|*symbol*|*characters*)    echo "csml" ;;
    pml*|*parallel*)                echo "pml" ;;
    *) echo "" ;;
  esac
}

detect_lib() {
  local file="$1"
  local fn_lower parent_lower
  fn_lower="$(basename -- "$file")"; fn_lower="${fn_lower,,}"
  parent_lower="$(basename "$(dirname "$file")")"; parent_lower="${parent_lower,,}"
  local lib
  lib="$(detect_lib_from_name "$fn_lower")"
  if [ -z "$lib" ]; then
    lib="$(detect_lib_from_name "$parent_lower")"
  fi
  echo "$lib"
}

strip_base() {
  local name="$1"
  echo "$name" | sed -E 's/(_v[0-9]+\.[0-9]+\.[0-9]+.*|_[0-9]{8}_[0-9]{4}.*)\.backup$//'
}

# ===========================================
# ORGANIZE: keep 10 recent, archive older ones
# ===========================================
organize_backups() {
  local lib="$1"
  local BK_ROOT="$HOME/kh-scripts/backup"
  local dir="$BK_ROOT"
  [ -n "$lib" ] && dir="$BK_ROOT/$lib"
  [ -d "$dir" ] || return 0

  mkdir -p "$dir/archive"

  local bases
  bases=$(ls "$dir" 2>/dev/null | grep -E '\.backup$' | while read -r f; do strip_base "$f"; done | sort -u)
  [ -z "$bases" ] && return 0

  while read -r base; do
    [ -z "$base" ] && continue
    mapfile -t files < <(ls -1t "$dir"/"$base"*".backup" 2>/dev/null)
    [ "${#files[@]}" -eq 0 ] && continue

    local count="${#files[@]}"
    if [ "$count" -gt 10 ]; then
      for ((i=10; i<count; i++)); do
        [ -e "${files[$i]}" ] && mv -f "${files[$i]}" "$dir/archive/"
      done
    fi
  done <<<"$bases"
}

# ==========================================
# SYNC: copy newest backup back into source
# ==========================================
sync_latest_to_source() {
  local lib="$1"
  local source_dir="$2"
  local BK_ROOT="$HOME/kh-scripts/backup"
  local dir="$BK_ROOT"
  [ -n "$lib" ] && dir="$BK_ROOT/$lib"
  [ -d "$dir" ] || return 0
  [ -d "$source_dir" ] || return 0

  mapfile -t src_files < <(find "$source_dir" -maxdepth 1 -type f -printf "%f\n" 2>/dev/null)

  for fname in "${src_files[@]}"; do
    [ -z "$fname" ] && continue
    local base="${fname%.*}"
    mapfile -t backups < <(ls -1t "$dir"/"$base"*".backup" 2>/dev/null)
    [ "${#backups[@]}" -eq 0 ] && continue

    local newest="${backups[0]}"
    local latest_copy="$source_dir/${base}_latest.backup"
    cp -f -- "$newest" "$latest_copy"
  done
}

# ============
# BACKUP LOGIC
# ============
# FAIL_REASONS associative array (bash 4+). For Termux bash, simulate with two parallel arrays if needed.
declare -a FAIL_FILES
declare -a FAIL_REASONS

backup_one() {
  local src="$1"
  local provided_lib="$2"
  local BK_ROOT="$HOME/kh-scripts/backup"

  case "$src" in
    "$BK_ROOT"|"$BK_ROOT"/*) return 5 ;;
  esac

  mkdir -p "$BK_ROOT"

  local fn parent lowerfn lowerparent lib
  fn="$(basename -- "$src")"
  parent="$(basename "$(dirname "$src")")"
  lowerfn="${fn,,}"
  lowerparent="${parent,,}"
  lib="${provided_lib:-}"
  [ -z "$lib" ] && lib="$(detect_lib "$src")"

  local lib_dir="$BK_ROOT"
  [ -n "$lib" ] && lib_dir="$BK_ROOT/$lib"
  mkdir -p "$lib_dir" "$lib_dir/archive"

  local script_version
  script_version="$(sed -n '1,120p' -- "$src" 2>/dev/null | sed -n 's/^[[:space:]]*SCRIPT_VERSION[[:space:]]*=[[:space:]]*["'\'']\(v[0-9]\+\.[0-9]\+\.[0-9]\+\)["'\'']/\1/p' | head -n1 || true)"

  local base_noext ts ds target
  base_noext="${fn%.*}"
  if printf '%s' "$fn" | grep -Eq '[_-]v[0-9]+\.[0-9]+\.[0-9]+'; then
    ts=$(date '+%Y%m%d_%H%M')
    target="${base_noext}_${ts}.backup"
  else
    if [ -n "$script_version" ]; then
      target="${base_noext}_${script_version}.backup"
    else
      ds=$(date '+%Y%m%d_%H%M')
      target="${base_noext}_${ds}.backup"
    fi
  fi

  local dest="$lib_dir/$target"

  # Capture cp stderr in a temp file so we can report it later
  local errfile
  errfile="$(mktemp)" || errfile="/tmp/bup_err.$$"
  if cp -p -- "$src" "$dest" 2> "$errfile"; then
    rm -f "$errfile" 2>/dev/null || true
    return 0
  else
    local reason
    reason="$(sed -n '1,3p' "$errfile" 2>/dev/null | tr -d '\n')"
    rm -f "$errfile" 2>/dev/null || true
    FAIL_FILES+=("$src")
    FAIL_REASONS+=("$reason")
    return 1
  fi
}

# ==================
# MAIN ENTRY POINT
# ==================
backup_script() {
  local input="$1"
  local provided_lib="$2"

  local SRC_ROOT="$HOME/kh-scripts"
  local BK_ROOT="$HOME/kh-scripts/backup"

  [ -n "$input" ] || {
    printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
    echo "${CLR_INFO}‚ÑπÔ∏è Usage:${CLR_RESET} bup <file-or-folder> [library]"
    echo
    return 2
  }

  local src="$input"
  if [ ! -e "$src" ]; then
    if [ -e "$SRC_ROOT/$input" ]; then
      src="$SRC_ROOT/$input"
    else
      printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
      echo "${CLR_ERR}‚ùå Not found:${CLR_RESET} $input or $SRC_ROOT/$input"
      echo
      return 3
    fi
  fi

  case "$src" in
    "$BK_ROOT"|"$BK_ROOT"/*)
      printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
      echo "${CLR_WARN}‚ö†Ô∏è Refusing to back up the backup folder or its contents:${CLR_RESET} $src"
      echo
      return 6
      ;;
  esac

  # Reset failure tracking arrays
  FAIL_FILES=()
  FAIL_REASONS=()

  if [ -f "$src" ]; then
    progress_init 1 || return 0

    local processed=0 failed=0
    if backup_one "$src" "$provided_lib"; then
      processed=$((processed+1))
    else
      failed=$((failed+1))
    fi
    progress_update
    progress_finish

    local lib_file source_dir
    lib_file="$(detect_lib "$src")"
    source_dir="$(dirname "$src")"
    organize_backups "$lib_file"
    sync_latest_to_source "$lib_file" "$source_dir"

    echo
    if [ "${#FAIL_FILES[@]}" -eq 0 ]; then
      echo -e "${CLR_BACKUP}${EMOJI_OK} ${CLR_RESET}${CLR_OK}${processed} Files Backed Up${CLR_RESET}"
    else
      echo -e "${CLR_BACKUP}${EMOJI_OK} ${CLR_RESET}${CLR_OK}${processed} Files Backed Up${CLR_RESET} | ${CLR_ERR}${EMOJI_FAIL_SUM} ${#FAIL_FILES[@]} File(s) Failed Backup${CLR_RESET}"
      echo
      echo -e "${CLR_WARN}Failed backups:${CLR_RESET}"
      local i=0
      for f in "${FAIL_FILES[@]}"; do
        printf "  ‚Ä¢ %s %s\n" "${EMOJI_FAIL_ITEM}" "$(basename "$f")"
        if [ -n "${FAIL_REASONS[$i]}" ] && [ -n "$VERBOSE" ]; then
          printf "      ‚Ü≥ %s\n" "${FAIL_REASONS[$i]}"
        fi
        i=$((i+1))
      done
      if [ -z "$VERBOSE" ]; then
        echo
        echo -e "${CLR_INFO}Tip:${CLR_RESET} run with ${CLR_SURPRISE}VERBOSE=1${CLR_RESET} to show cp error text for each failed file."
      fi
    fi
    echo
    return 0

  elif [ -d "$src" ]; then
    local total_files processed failed
    total_files=$(find "$src" -maxdepth 1 -type f | wc -l)
    total_files=${total_files//[[:space:]]/}

    progress_init "$total_files" || return 0

    processed=0
    failed=0

    for f in "$src"/*; do
      [ -f "$f" ] || continue
      if backup_one "$f" "$provided_lib"; then
        processed=$((processed+1))
      else
        failed=$((failed+1))
      fi
      progress_update
    done

    progress_finish

    local lib_candidate fn parent lowerfn lowerparent
    fn="$(basename -- "$src")"; lowerfn="${fn,,}"
    parent="$(basename "$(dirname "$src")")"; lowerparent="${parent,,}"
    lib_candidate="$(detect_lib_from_name "$lowerfn")"
    [ -z "$lib_candidate" ] && lib_candidate="$(detect_lib_from_name "$lowerparent")"

    organize_backups "$lib_candidate"
    sync_latest_to_source "$lib_candidate" "$src"

    echo
    if [ "${#FAIL_FILES[@]}" -eq 0 ]; then
      echo -e "${CLR_BACKUP}${EMOJI_OK} ${CLR_RESET}${CLR_OK}${processed} Files Backed Up${CLR_RESET}"
    else
      echo -e "${CLR_BACKUP}${EMOJI_OK} ${CLR_RESET}${CLR_OK}${processed} Files Backed Up${CLR_RESET} | ${CLR_ERR}${EMOJI_FAIL_SUM} ${#FAIL_FILES[@]} File(s) Failed Backup${CLR_RESET}"
      echo
      echo -e "${CLR_WARN}Failed backups:${CLR_RESET}"
      local i=0
      for f in "${FAIL_FILES[@]}"; do
        printf "  ‚Ä¢ %s %s\n" "${EMOJI_FAIL_ITEM}" "$(basename "$f")"
        if [ -n "${FAIL_REASONS[$i]}" ] && [ -n "$VERBOSE" ]; then
          printf "      ‚Ü≥ %s\n" "${FAIL_REASONS[$i]}"
        fi
        i=$((i+1))
      done
      if [ -z "$VERBOSE" ]; then
        echo
        echo -e "${CLR_INFO}Tip:${CLR_RESET} run with ${CLR_SURPRISE}VERBOSE=1${CLR_RESET} to show cp error text for each failed file."
      fi
    fi
    echo
    return 0

  else
    printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
    echo "${CLR_ERR}‚ùå Unsupported type:${CLR_RESET} $src"
    echo
    return 4
  fi
}

backup_script "$@"

#!/usr/bin/env bash
# File: $HOME/kh-scripts/bup
# Purpose: bup v1.6.6 ‚Äî stable single-line progress rendering,
#          explicit skipped tracking, robust failure capture, archiving (keep 10),
#          and sync newest backup to source

SCRIPT_VERSION="v1.6.6"

CLR_OK=$'\e[38;2;0;200;0m'
CLR_WARN=$'\e[38;2;255;200;0m'
CLR_ERR=$'\e[38;2;220;0;0m'
CLR_INFO=$'\e[38;2;120;160;255m'
CLR_BACKUP=$'\e[38;2;0;180;220m'
CLR_SURPRISE=$'\e[38;2;255;100;200m'
CLR_RESET=$'\e[0m'

EMOJI_OK="üì¶"
EMOJI_FAIL_SUM="‚ùå"
EMOJI_FAIL_ITEM="‚ùó"
EMOJI_SKIP_ITEM="‚ö™"

PB_TOTAL=0; PB_CURRENT=0; PB_START=0

progress_init(){
  PB_TOTAL=$1
  PB_CURRENT=0
  PB_START=$(date +%s)

  if [ "$PB_TOTAL" -le 0 ]; then
    printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
    printf "${CLR_INFO}‚ÑπÔ∏è No files to back up${CLR_RESET}\n\n"
    return 1
  fi

  printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
  return 0
}

progress_update(){
  PB_CURRENT=$((PB_CURRENT+1))
  progress_render
}

progress_render(){
  local now elapsed pct width fill_len empty_len eta eta_min eta_sec eta_str pct_disp full
  now=$(date +%s)
  elapsed=$((now - PB_START))
  [ $elapsed -le 0 ] && elapsed=1

  pct=$(awk -v c=$PB_CURRENT -v t=$PB_TOTAL 'BEGIN {printf "%.4f", (t>0 ? c/t : 0)}')

  width=$(tput cols 2>/dev/null || echo 80)
  width=$((width - 50))
  [ $width -lt 30 ] && width=30

  fill_len=$(awk -v w=$width -v p=$pct 'BEGIN {printf "%d", w*p}')
  empty_len=$((width - fill_len))

  local filled empty divider bar
  full=0
  [ "$PB_CURRENT" -ge "$PB_TOTAL" ] && full=1

  if [ "$fill_len" -gt 0 ]; then
    filled="${CLR_BACKUP}$(printf '‚îÅ%.0s' $(seq 1 $fill_len 2>/dev/null))${CLR_RESET}"
  else
    filled=""
  fi

  if [ "$empty_len" -gt 0 ]; then
    empty="${CLR_INFO}$(printf '‚îÄ%.0s' $(seq 1 $empty_len 2>/dev/null))${CLR_RESET}"
  else
    empty=""
  fi

  divider=""
  if [ $full -eq 0 ] && [ $fill_len -lt $width ]; then
    divider="${CLR_OK}‚ï∏${CLR_RESET}"
  fi
  bar="${filled}${divider}${empty}"

  if [ $full -eq 1 ]; then
    eta=0
  else
    eta=$(( (PB_TOTAL - PB_CURRENT) * elapsed / (PB_CURRENT>0?PB_CURRENT:1) ))
    [ $eta -lt 0 ] && eta=0
  fi
  eta_min=$((eta/60))
  eta_sec=$((eta%60))
  eta_str=$(printf "%02d:%02d" $eta_min $eta_sec)

  if [ $full -eq 1 ]; then
    pct_disp="100.0"
  else
    pct_disp=$(awk -v p=$pct 'BEGIN {printf "%5.1f", p*100}')
  fi

  # Clear line then print new bar to avoid leftover characters from previous longer lines
  printf '\r\033[K'
  printf "%s" "$(printf "${CLR_OK}%3d${CLR_RESET}/${CLR_INFO}%d${CLR_RESET} [%s] ${CLR_OK}%s%%%s ETA ${CLR_INFO}%s${CLR_RESET}" \
    "$PB_CURRENT" "$PB_TOTAL" "$bar" "$pct_disp" "" "$eta_str")"
}

progress_finish(){
  PB_CURRENT="$PB_TOTAL"
  progress_render
  echo
}

# helpers: detection & paths
detect_lib_from_name(){
  local fn_lower="$1"
  case "$fn_lower" in
    cml*|*truecolor*|*colormaster*) echo "cml" ;;
    dbml*|*dynamicbox*|*box*)       echo "dbml" ;;
    csml*|*symbol*|*characters*)    echo "csml" ;;
    pml*|*parallel*)                echo "pml" ;;
    *) echo "" ;;
  esac
}

detect_lib(){
  local file="$1"
  local fn_lower parent_lower
  fn_lower="$(basename -- "$file")"; fn_lower="${fn_lower,,}"
  parent_lower="$(basename "$(dirname "$file")")"; parent_lower="${parent_lower,,}"
  local lib
  lib="$(detect_lib_from_name "$fn_lower")"
  if [ -z "$lib" ]; then
    lib="$(detect_lib_from_name "$parent_lower")"
  fi
  echo "$lib"
}

strip_base(){
  local name="$1"
  echo "$name" | sed -E 's/(_v[0-9]+\.[0-9]+\.[0-9]+.*|_[0-9]{8}_[0-9]{4}.*)\.backup$//'
}

# organize backups: keep 10 recent, archive older ones
organize_backups(){
  local lib="$1"
  local BK_ROOT="$HOME/kh-scripts/backup"
  local dir="$BK_ROOT"
  [ -n "$lib" ] && dir="$BK_ROOT/$lib"
  [ -d "$dir" ] || return 0

  mkdir -p "$dir/archive"

  local bases
  bases=$(ls "$dir" 2>/dev/null | grep -E '\.backup$' | while read -r f; do strip_base "$f"; done | sort -u)
  [ -z "$bases" ] && return 0

  while read -r base; do
    [ -z "$base" ] && continue
    mapfile -t files < <(ls -1t "$dir"/"$base"*".backup" 2>/dev/null)
    [ "${#files[@]}" -eq 0 ] && continue

    local count="${#files[@]}"
    if [ "$count" -gt 10 ]; then
      for ((i=10;i<count;i++)); do
        [ -e "${files[$i]}" ] && mv -f "${files[$i]}" "$dir/archive/"
      done
    fi
  done <<<"$bases"
}

# sync latest backup copy back to source directory as *_latest.backup
sync_latest_to_source(){
  local lib="$1"
  local source_dir="$2"
  local BK_ROOT="$HOME/kh-scripts/backup"
  local dir="$BK_ROOT"
  [ -n "$lib" ] && dir="$BK_ROOT/$lib"
  [ -d "$dir" ] || return 0
  [ -d "$source_dir" ] || return 0

  mapfile -t src_files < <(find "$source_dir" -maxdepth 1 -type f -printf "%f\n" 2>/dev/null)

  for fname in "${src_files[@]}"; do
    [ -z "$fname" ] && continue
    local base="${fname%.*}"
    mapfile -t backups < <(ls -1t "$dir"/"$base"*".backup" 2>/dev/null)
    [ "${#backups[@]}" -eq 0 ] && continue

    local newest="${backups[0]}"
    local latest_copy="$source_dir/${base}_latest.backup"
    cp -f -- "$newest" "$latest_copy" 2>/dev/null || true
  done
}

# robust logs
FAIL_LOG="$(mktemp "${TMPDIR:-/tmp}/bup_fail.XXXXXX")" || FAIL_LOG="/tmp/bup_fail.$$"
SKIP_LOG="$(mktemp "${TMPDIR:-/tmp}/bup_skip.XXXXXX")" || SKIP_LOG="/tmp/bup_skip.$$"

: > "$FAIL_LOG"
: > "$SKIP_LOG"

# backup_one: returns
# 0 = success
# 1 = failure (writing to FAIL_LOG)
# 5 = intentional skip (writes to SKIP_LOG at caller)
backup_one(){
  local src="$1"
  local provided_lib="$2"
  local BK_ROOT="$HOME/kh-scripts/backup"

  case "$src" in
    "$BK_ROOT"|"$BK_ROOT"/*) return 5 ;;
  esac

  mkdir -p "$BK_ROOT"

  local fn parent lowerfn lowerparent lib
  fn="$(basename -- "$src")"
  parent="$(basename "$(dirname "$src")")"
  lowerfn="${fn,,}"
  lowerparent="${parent,,}"
  lib="${provided_lib:-}"
  [ -z "$lib" ] && lib="$(detect_lib "$src")"

  # Defensive skip: refuse to back up files that look like backups
  case "$lowerfn" in
    *bak*|*backup*) return 5 ;;
  esac

  local lib_dir="$BK_ROOT"
  [ -n "$lib" ] && lib_dir="$BK_ROOT/$lib"
  mkdir -p "$lib_dir" "$lib_dir/archive"

  local script_version
  script_version="$(sed -n '1,120p' -- "$src" 2>/dev/null | sed -n 's/^[[:space:]]*SCRIPT_VERSION[[:space:]]*=[[:space:]]*["'\'']\(v[0-9]\+\.[0-9]\+\.[0-9]\+\)["'\'']/\1/p' | head -n1 || true)"

  local base_noext ts ds target
  base_noext="${fn%.*}"
  if printf '%s' "$fn" | grep -Eq '[_-]v[0-9]+\.[0-9]+\.[0-9]+'; then
    ts=$(date '+%Y%m%d_%H%M')
    target="${base_noext}_${ts}.backup"
  else
    if [ -n "$script_version" ]; then
      target="${base_noext}_${script_version}.backup"
    else
      ds=$(date '+%Y%m%d_%H%M')
      target="${base_noext}_${ds}.backup"
    fi
  fi

  local dest="$lib_dir/$target"

  # capture cp stderr reliably
  local err
  err="$(mktemp "${TMPDIR:-/tmp}/bup_cp.XXXXXX" 2>/dev/null || printf '/tmp/bup_cp.%s' "$$")"
  if cp -p -- "$src" "$dest" 2> "$err"; then
    rm -f "$err" 2>/dev/null || true
    return 0
  else
    local reason
    reason="$(sed -n '1,5p' "$err" 2>/dev/null | tr '\n' ' ' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
    rm -f "$err" 2>/dev/null || true
    printf '%s\t%s\n' "$(basename -- "$src")" "${reason:-cp failed}" >> "$FAIL_LOG"
    return 1
  fi
}

backup_script(){
  local input="$1"
  local provided_lib="$2"

  local SRC_ROOT="$HOME/kh-scripts"
  local BK_ROOT="$HOME/kh-scripts/backup"

  [ -n "$input" ] || {
    printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
    echo "${CLR_INFO}‚ÑπÔ∏è Usage:${CLR_RESET} bup <file-or-folder> [library]"
    echo
    return 2
  }

  local src="$input"
  if [ ! -e "$src" ]; then
    if [ -e "$SRC_ROOT/$input" ]; then
      src="$SRC_ROOT/$input"
    else
      printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
      echo "${CLR_ERR}‚ùå Not found:${CLR_RESET} $input or $SRC_ROOT/$input"
      echo
      return 3
    fi
  fi

  case "$src" in
    "$BK_ROOT"|"$BK_ROOT"/*)
      printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
      echo "${CLR_WARN}‚ö†Ô∏è Refusing to back up the backup folder or its contents:${CLR_RESET} $src"
      echo
      return 6
      ;;
  esac

  # reset logs for this run
  : > "$FAIL_LOG"
  : > "$SKIP_LOG"

  if [ -f "$src" ]; then
    local base
    base="$(basename -- "$src")"
    case "${base,,}" in
      *bak*|*backup*)
        printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
        echo "${CLR_INFO}‚ÑπÔ∏è Skipping file: ${CLR_RESET}$base (contains 'bak' or 'backup')"
        printf '%s\n' "$base" >> "$SKIP_LOG"
        echo
        return 0
        ;;
    esac

    progress_init 1 || return 0

    local processed=0 failed=0 skipped=0
    backup_one "$src" "$provided_lib"
    rc=$?
    if [ $rc -eq 0 ]; then
      processed=$((processed+1))
    elif [ $rc -eq 5 ]; then
      skipped=$((skipped+1))
      printf '%s\n' "$(basename -- "$src")" >> "$SKIP_LOG"
    else
      failed=$((failed+1))
    fi

    # exactly one progress update for the discovered file
    progress_update
    progress_finish

    local lib_file source_dir
    lib_file="$(detect_lib "$src")"
    source_dir="$(dirname "$src")"

    organize_backups "$lib_file"
    sync_latest_to_source "$lib_file" "$source_dir"

    echo
    local failcount skipcount
    failcount=$(wc -l < "$FAIL_LOG" 2>/dev/null | sed -E 's/\1//g')
    skipcount=$(wc -l < "$SKIP_LOG" 2>/dev/null | sed -E 's/\1//g')

    if [ "$failcount" -eq 0 ]; then
      echo -e "${CLR_BACKUP}${EMOJI_OK} ${CLR_RESET}${CLR_OK}${processed} Files Backed Up${CLR_RESET}"
    else
      echo -e "${CLR_BACKUP}${EMOJI_OK} ${CLR_RESET}${CLR_OK}${processed} Files Backed Up${CLR_RESET} | ${CLR_ERR}${EMOJI_FAIL_SUM} ${failcount} File(s) Failed Backup${CLR_RESET}"
    fi

    if [ "$skipcount" -gt 0 ]; then
      echo
      echo -e "${CLR_INFO}Skipped:${CLR_RESET} ${skipcount} file(s)"
      while IFS= read -r s; do printf "  ‚Ä¢ %s %s\n" "${EMOJI_SKIP_ITEM}" "$s"; done < "$SKIP_LOG"
    fi

    if [ "$failcount" -gt 0 ]; then
      echo
      echo -e "${CLR_WARN}Failed backups:${CLR_RESET}"
      while IFS=$'\t' read -r fname reason; do
        printf "  ‚Ä¢ %s %s\n" "${EMOJI_FAIL_ITEM}" "$fname"
        if [ -n "$reason" ] && [ -n "$VERBOSE" ]; then
          printf "      ‚Ü≥ %s\n" "$reason"
        fi
      done < "$FAIL_LOG"
      if [ -z "$VERBOSE" ]; then
        echo
        echo -e "${CLR_INFO}Tip:${CLR_RESET} run with ${CLR_SURPRISE}VERBOSE=1${CLR_RESET} to show cp error text."
      fi
    fi

    echo
    return 0

  elif [ -d "$src" ]; then
    # Count all regular files discovered in folder so PB_TOTAL matches the number of updates
    total_files=$(find "$src" -maxdepth 1 -type f | wc -l)
    total_files=${total_files//[[:space:]]/}

    progress_init "$total_files" || return 0

    local processed=0 failed=0 skipped=0

    for f in "$src"/*; do
      [ -f "$f" ] || continue
      base="$(basename -- "$f")"
      case "${base,,}" in
        *bak*|*backup*)
          # intentionally skipped; still considered a discovered file so we update the progress
          printf '%s\n' "$base" >> "$SKIP_LOG"
          skipped=$((skipped+1))
          progress_update
          continue
          ;;
      esac

      backup_one "$f" "$provided_lib"
      rc=$?
      if [ $rc -eq 0 ]; then
        processed=$((processed+1))
      elif [ $rc -eq 5 ]; then
        skipped=$((skipped+1))
        printf '%s\n' "$base" >> "$SKIP_LOG"
      else
        failed=$((failed+1))
      fi

      # exactly one progress update per discovered file
      progress_update
    done

    progress_finish

    local lib_candidate fn parent lowerfn lowerparent
    fn="$(basename -- "$src")"; lowerfn="${fn,,}"
    parent="$(basename "$(dirname "$src")")"; lowerparent="${parent,,}"
    lib_candidate="$(detect_lib_from_name "$lowerfn")"
    [ -z "$lib_candidate" ] && lib_candidate="$(detect_lib_from_name "$lowerparent")"

    organize_backups "$lib_candidate"
    sync_latest_to_source "$lib_candidate" "$src"

    echo
    local failcount skipcount
    failcount=$(wc -l < "$FAIL_LOG" 2>/dev/null | sed -E 's/\1//g')
    skipcount=$(wc -l < "$SKIP_LOG" 2>/dev/null | sed -E 's/\1//g')

    if [ "$failcount" -eq 0 ]; then
      echo -e "${CLR_BACKUP}${EMOJI_OK} ${CLR_RESET}${CLR_OK}${processed} Files Backed Up${CLR_RESET}"
    else
      echo -e "${CLR_BACKUP}${EMOJI_OK} ${CLR_RESET}${CLR_OK}${processed} Files Backed Up${CLR_RESET} | ${CLR_ERR}${EMOJI_FAIL_SUM} ${failcount} File(s) Failed Backup${CLR_RESET}"
    fi

    if [ "$skipcount" -gt 0 ]; then
      echo
      echo -e "${CLR_INFO}Skipped:${CLR_RESET} ${skipcount} file(s)"
      while IFS= read -r s; do printf "  ‚Ä¢ %s %s\n" "${EMOJI_SKIP_ITEM}" "$s"; done < "$SKIP_LOG"
    fi

    if [ "$failcount" -gt 0 ]; then
      echo
      echo -e "${CLR_WARN}Failed backups:${CLR_RESET}"
      while IFS=$'\t' read -r fname reason; do
        printf "  ‚Ä¢ %s %s\n" "${EMOJI_FAIL_ITEM}" "$fname"
        if [ -n "$reason" ] && [ -n "$VERBOSE" ]; then
          printf "      ‚Ü≥ %s\n" "$reason"
        fi
      done < "$FAIL_LOG"
      if [ -z "$VERBOSE" ]; then
        echo
        echo -e "${CLR_INFO}Tip:${CLR_RESET} run with ${CLR_SURPRISE}VERBOSE=1${CLR_RESET} to show cp error text."
      fi
    fi

    echo
    return 0

  else
    printf "\n${CLR_SURPRISE}===== BASH BACKUP SCRIPT %s =====${CLR_RESET}\n\n" "$SCRIPT_VERSION"
    echo "${CLR_ERR}‚ùå Unsupported type:${CLR_RESET} $src"
    echo
    return 4
  fi
}

backup_script "$@"
